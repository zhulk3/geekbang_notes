数据库调优就是为了让数据查询更快，存储空间利用更高效。

![img](https://static001.geekbang.org/resource/image/d3/b0/d3bc10314c3532f053304a00765183b0.jpg?wh=2408*2313)

# 范式

范式理解为，一张数据表的设计结构需要满足的某种设计标准的级别。

1NF 指的是数据库表中的任何属性都是原子性的，不可再分。

2NF 指的数据表里的非主属性都要和这个数据表的候选键有完全依赖关系。所谓完全依赖不同于部分依赖，也就是不能仅依赖候选键的一部分属性，而必须依赖全部属性。否则会出现数据冗余。

3NF 在满足 2NF 的同时，对任何非主属性都不传递依赖于候选键。也就是说不能存在非主属性 A 依赖于非主属性 B，非主属性 B 依赖于候选键的情况。

![img](https://static001.geekbang.org/resource/image/e7/11/e775113e733020a7810196afd4f58711.jpg?wh=3341*1778)

# BCNF

![img](https://static001.geekbang.org/resource/image/ac/fb/acbb07c269c85683cc981c7f677d32fb.jpg?wh=3341*1521)

# 索引

索引就是帮助数据库管理系统高效获取数据的数据结构。

功能逻辑上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引和全文索引。

## 从功能逻辑上分：

普通索引是基础的索引，没有任何约束，主要用于提高查询效率。

唯一索引就是在普通索引的基础上增加了数据唯一性的约束，在一张数据表里可以有多个唯一索引，唯一索引可以在一列或者多列上建立，但是要确保值是唯一的。

主键索引在唯一索引的基础上增加了不为空的约束，也就是 NOT NULL+UNIQUE，一张表里最多只有一个主键索引。

全文索引用的不多，MySQL 自带的全文索引只支持英文。我们通常可以采用专门的全文搜索引擎，比如 ES(ElasticSearch) 和 Solr。

## 按照物理实现方式分：

聚集索引：找到索引后，后面就是要找的数据；聚集索引指表中数据行按索引的排序方式进行存储，对查找行很有效。只有当表包含聚集索引时，表内的数据行才会按找索引列的值在磁盘上进行物理排序和存储。每一个表只能有一个聚集索引，因为数据行本身只能按一个顺序存储。

非聚集索引，有单独的存储空间存放索引，索引项是按照顺序存储的，但索引项指向的内容是随机存储的。也就是说系统会进行两次查找，第一次先找到索引，第二次找到索引对应的位置取出数据行。

- 聚集索引的叶子节点存储的就是我们的数据记录，非聚集索引的叶子节点存储的是数据位置。非聚集索引不会影响数据表的物理存储顺序。
- 一个表只能有一个聚集索引，因为只能有一种排序存储的方式，但可以有多个非聚集索引，也就是多个索引目录提供数据检索。
- 使用聚集索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚集索引低。

# 索引的原理

B 树的英文是 Balance Tree，也就是平衡的多路搜索树，它的高度远小于平衡二叉树的高度。在文件系统和数据库系统中的索引结构经常采用 B 树来实现。

![img](https://static001.geekbang.org/resource/image/18/44/18031c20f9a4be3e858743ed99f3c144.jpg?wh=1176*518)

![img](https://static001.geekbang.org/resource/image/55/32/551171d94a69fbbfc00889f8b1f45932.jpg?wh=1002*674) 

![img](https://static001.geekbang.org/resource/image/92/90/922bfe97e007d24f4467f5af4e1a0790.jpg?wh=2766*2313)

# Hash索引

Hash 索引与 B+ 树索引的区别

- 我们之前讲到过 B+ 树索引的结构，Hash 索引结构和 B+ 树的不同，因此在索引使用上也会有差别。Hash 索引不能进行范围查询，而 B+ 树可以。这是因为 Hash 索引指向的数据是无序的，而 B+ 树的叶子节点是个有序的链表。
- Hash 索引不支持联合索引的最左侧原则（即联合索引的部分索引无法使用），而 B+ 树可以。对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。
- Hash 索引不支持 ORDER BY 排序，因为 Hash 索引指向的数据是无序的，因此无法起到排序优化的作用，而 B+ 树索引数据是有序的，可以起到对该字段 ORDER BY 排序优化的作用。同理，我们也无法用 Hash 索引进行模糊查询，而 B+ 树使用 LIKE 进行模糊查询的时候，LIKE 后面前模糊查询（比如 % 开头）的话就可以起到优化作用。

# 从数据页的角度理解B+树

![img](https://static001.geekbang.org/resource/image/c1/74/c127149aad62be7a1ee2c366757a2e74.jpg?wh=2272*2313)

# 乐观锁和悲观锁

粒度角度：分为行锁、页锁、表锁。

数据库管理角度：共享锁和排他锁。

意向锁（Intent Lock），简单来说就是给更大一级别的空间示意里面是否已经上过锁。

返回数据表的场景，如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。

## 从程序员角度划分：

乐观锁（Optimistic Locking）认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，我们可以采用版本号机制或者时间戳机制实现。

悲观锁（Pessimistic Locking）也是一种思想，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。

![img](https://static001.geekbang.org/resource/image/97/7f/9794e3a155edbf8d7b68a7ff8910fc7f.jpg?wh=3011*2313)

# MVCC

保存数据的历史版本；

## 优势

- 读写不阻塞，提高并发度；
- 降低死锁概率，读数据不需要加锁，写数据只需要锁特定数据行；
- 解决一致性读的问题。

## InnoDB中的MVCC如何实现

事物版本号：每开启一个事务，我们都会从数据库中获得一个事务 ID（也就是事务版本号），这个事务 ID 是自增长的，通过 ID 大小，我们就可以判断事务的时间顺序。

隐藏列：

- db_row_id：隐藏的行 ID，用来生成默认聚集索引。如果我们创建数据表的时候没有指定聚集索引，这时 InnoDB 就会用这个隐藏 ID 来创建聚集索引。采用聚集索引的方式可以提升数据的查找效率。
- db_trx_id：操作这个数据的事务 ID，也就是最后一个对该数据进行插入或更新的事务 ID。
- db_roll_ptr：回滚指针，也就是指向这个记录的 Undo Log 信息。

Undo Log

nnoDB 将行记录快照保存在了 Undo Log 里。

![img](https://static001.geekbang.org/resource/image/47/81/4799c77b8cdfda50e49a391fea727281.png?wh=838*538)

## 查询一条记录时，如何通过MVCC的步骤找到它

- 获取自己的事务id（事务1），和read view（创建当前事务时会创建）；
- 获取当前记录的最后一次更新的事务id；将此id与read view中的id列表（创建事务1时仍然活跃的事务）进行比较，如果id<low_id(最早），则这个low_id代表的事务已经提交，行记录可见，如果low_id<id<up_id, 说明id代表的事务可能还是活跃的，需要判断id是否在ids中，如果不在，则已经提交，可见，否则不可见，去undo log中获取记录；如果id>up_id, 不可见，去undo log中获取记录。