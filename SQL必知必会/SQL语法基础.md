# 了解SQL

## SQL语言按照功能可以分为四部分：

DDL，data definition language, 定义数据库，创建、删除、修改数据库；

DML，data manipulation language, 比如增加、删除、修改记录；

DCL，data control language, 比如控制数据库权限；

DQL，data query language, 查询数据库。



### 大小写问题

表名，表别名，字段名，字段别名都小写，SQL保留字，函数名，绑定变量大写。



### DBMS的前世今生

![DBMS](https://static001.geekbang.org/resource/image/a7/91/a7237ddbe4ca69353bd21a6eff35d391.png?wh=702*770)

键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，同时缺点也很明显，它无法像关系型数据库一样自由使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。键值型数据库典型的使用场景是作为内容缓存。Redis 是最流行的键值型数据库。

文档型数据库用来管理文档，在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录，MongoDB 是最流行的文档型数据库。

搜索引擎也是数据库检索中的重要应用，常见的全文搜索引擎有 Elasticsearch、Splunk 和 Solr。虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎的优势在于采用了全文搜索的技术，核心原理是“倒排索引”。

列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限。列式数据库将数据按照列进行存储，因为每列的数据格式是相同的，在存储过程时，可以使用有效的压缩算法进行压缩存储，在读取时，可以只读取需要的列到内存中，但如果是行式数据库，就需要将整行数据读入内存中，所以说列式数据库按照列式存储数据会大量降低系统的IO

图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。

# SQL是如何执行的

## Oracle执行过程

![oracal执行过程](https://static001.geekbang.org/resource/image/4b/70/4b43aeaf9bb0fe2d576757d3fef50070.png?wh=1176*420)

- 语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。

- 语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。
- 权限检查：看用户是否具备访问该数据的权限。
- 共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash 值在库缓存（Library Cache）中查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是软解析。如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是硬解析。
- 优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。
- 执行器：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。

可以通过使用绑定变量来减少硬解析，减少 Oracle 的解析工作量。但是这种方式也有缺点，使用动态 SQL 的方式，因为参数不同，会导致 SQL 的执行效率不同，同时 SQL 优化也会比较困难。

## MySQL执行过程

![MySQL process](https://static001.geekbang.org/resource/image/c4/9e/c4b24ef2377e0d233af69925b0d7139e.png?wh=900*480)

- 连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；

- SQL 层：对 SQL 语句进行查询处理；

- 存储引擎层：与数据库文件打交道，负责数据的存储和读取

  ![](https://static001.geekbang.org/resource/image/30/79/30819813cc9d53714c08527e282ede79.jpg?wh=466*598)

与 Oracle 不同的是，MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：

- InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。
- MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。



# DDL

常用功能是增、删、改，对应命令 CREATE, DROP, ALTER, 不需要commit。

创建数据表：

`CREATE DATABASE nba; // 创建一个名为nba的数据库
DROP DATABASE nba; // 删除一个名为nba的数据库`

创建数据表：

`CREATE TABLE [table_name](字段名 数据类型，......)`

添加字段：

`ALTER TABLE player ADD (age int(11));`

修改字段名：

`ALTER TABLE player RENAME COLUMN age to player_age`

修改字段类型：

`ALTER TABLE player MODIFY (player_age float(3,1));`

删除字段

`ALTER TABLE player DROP COLUMN player_age;`

### 数据表的约束

主键约束：唯一且非空，可以是一个字段也可以是多个字段；

外键，确保了表与表之间引用的完整性，可以重复也可以是空的；

唯一性约束、not null约束，default约束、check约束；

### 设计数据表的三少一多原则

数据表越少越好，数据表越少，证明实体与联系设计得越简洁；

数据表中的字段越少越好，字段越少，冗余越小；

联合主键的字段个数越少越好，联合主键越多，占用索引看见越大；

使用主键和外键越多越好，冗余度低，利用度高。

# select

关键字顺序：

`SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...`

执行顺序：

`FROM > WHERE > GROUP BY > HAVING > SELECT的字段 > DISTINCT > ORDER BY > LIMIT`

在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。

# 数据过滤

比较符

![img](https://static001.geekbang.org/resource/image/3a/e0/3a2667784b4887ef15becc7056f3d3e0.png?wh=799*545)

逻辑运算符：

![img](https://static001.geekbang.org/resource/image/ae/c1/aeed170c57ae1e5378fbee9f8fb6a8c1.png?wh=796*272)

![img](https://static001.geekbang.org/resource/image/fb/50/fbd79c2c90a58891b498e7f29d935050.jpg?wh=3341*1713)

# SQL函数

SQL 中的函数一般是在数据上执行的，可以很方便地转换和处理数据；

## 内置函数

![img](https://static001.geekbang.org/resource/image/19/e1/193b171970c90394576d3812a46dd8e1.png?wh=1243*256)

![img](https://static001.geekbang.org/resource/image/c1/4d/c161033ebeeaa8eb2436742f0f818a4d.png?wh=1237*568)

# 聚集函数

它是对一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。

![img](https://static001.geekbang.org/resource/image/d1/15/d101026459ffa96504ba3ebb85054415.png?wh=776*326)

COUNT(*) 只是统计数据行数，不管某个字段是否为 NULL。

## 对数据进行分组

使用GROUP BY, 也可以使用多个字段进行分组，这就相当于把这些字段可能出现的所有的取值情况都进行分组。实际上过滤分组我们使用的是 HAVING。HAVING 的作用和 WHERE 一样，都是起到过滤的作用，只不过 WHERE 是用于数据行，而 HAVING 则作用于分组。HAVING 支持所有 WHERE 的操作，因此所有需要 WHERE 子句实现的功能，你都可以使用 HAVING 对分组进行筛选。

关键字顺序：

`SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...`

# 子查询

子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做非关联子查询。

同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为关联子查询。

# SQL 92中的连接

SQL92 中的 5 种连接方式，它们分别是笛卡尔积、等值连接、非等值连接、外连接（左连接、右连接）和自连接。

笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。

两张表的等值连接就是用两张表中都存在的列进行连接。

# SQL 99中的连接

交叉连接：笛卡尔积；

自然连接：等值连接；

# 视图

视图作为一张虚拟表，帮我们封装了底层与数据表的接口。它相当于是一张表或多张表的数据结果集。视图的这一特点，可以帮我们简化复杂的 SQL 查询，比如在编写视图后，我们就可以直接重用它，而不需要考虑视图中包含的基础查询的细节。同样，我们也可以根据需要更改数据格式，返回与底层数据表格式不同的数据。

![img](https://static001.geekbang.org/resource/image/8a/30/8afa99e7d1ac1de2c802cf0c61004b30.jpg?wh=3341*1916)

# 存储过程

存储过程可以说是由 SQL 语句和流控制语句构成的语句集合，它和我们之前学到的函数一样，可以接收输入参数，也可以返回输出参数给调用者，返回计算结果。

![img](https://static001.geekbang.org/resource/image/54/9f/54a0d3b0c0e5336c1da6fc84c909a49f.jpg?wh=2376*2313)

# 事物

事务的特性：ACID我刚才提到了事务的特性：要么完全执行，要么都不执行。不过要对事务进行更深一步的理解，还要从事务的 4 个特性说起，这 4 个特性用英文字母来表达就是 ACID。

- A，也就是原子性（Atomicity）。原子的概念就是不可分割，你可以把它理解为组成物质的基本单位，也是我们进行数据处理操作的基本单位。
- C，就是一致性（Consistency）。一致性指的就是数据库在进行事务操作后，会由原来的一致状态，变成另一种一致的状态。也就是说当事务提交后，或者当事务发生回滚后，数据库的完整性约束不能被破坏。
- I，就是隔离性（Isolation）。它指的是每个事务都是彼此独立的，不会受到其他事务的执行影响。也就是说一个事务在提交之前，对其他事务都是不可见的。
- 最后一个 D，指的是持久性（Durability）。事务提交之后对数据的修改是持久性的，即使在系统出故障的情况下，比如系统崩溃或者存储介质发生故障，数据的修改依然是有效的。因为当事务完成，数据库的日志就会被更新，这时可以通过日志，让系统恢复到最后一次成功的更新状态。



# 隔离

- 脏读：读到了其他事务还没有提交的数据。
- 不可重复读：对某数据进行读取，发现两次读取的结果不同，也就是说没有读到相同的内容。这是因为有其他事务对这个数据同时进行了修改或删除。
- 幻读：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 更改或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候发现会有 N+M 条数据，产生了幻读。

## 四种隔离级别

![img](https://static001.geekbang.org/resource/image/b0/95/b07103c5f5486aec5e2daf1dacfd6f95.png?wh=793*209)

读未提交，也就是允许读到未提交的数据，这种情况下查询是不会使用锁的，可能会产生脏读、不可重复读、幻读等情况。

读已提交就是只能读到已经提交的内容，可以避免脏读的产生，属于 RDBMS 中常见的默认隔离级别（比如说 Oracle 和 SQL Server），但如果想要避免不可重复读或者幻读，就需要我们在 SQL 查询的时候编写带加锁的 SQL 语句（我会在进阶篇里讲加锁）。

可重复读，保证一个事务在相同查询条件下两次查询得到的数据结果是一致的，可以避免不可重复读和脏读，但无法避免幻读。MySQL 默认的隔离级别就是可重复读。

可串行化，将事务进行串行化，也就是在一个队列中按照顺序执行，可串行化是最高级别的隔离等级，可以解决事务读取中所有可能出现的异常情况，但是它牺牲了系统的并发性。